
@article{local_mark_scan,
	title = {Cyclic reference counting with local mark-scan},
	volume = {34},
	issn = {0020-0190},
	url = {https://www.sciencedirect.com/science/article/pii/002001909090226N},
	doi = {10.1016/0020-0190(90)90226-N},
	number = {1},
	urldate = {2024-09-15},
	journal = {Information Processing Letters},
	author = {Martínez, Alejandro D. and Wachenchauzer, Rosita and Lins, Rafael D.},
	month = feb,
	year = {1990},
	keywords = {garbage collection, reference counting, analysis of algorithms, Compilers, functional programming},
	pages = {31--35},
	file = {PDF:C\:\\Users\\yasht\\Zotero\\storage\\KF6EMQ3M\\Martínez et al. - 1990 - Cyclic reference counting with local mark-scan.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\yasht\\Zotero\\storage\\MGH39B3R\\002001909090226N.html:text/html},
}


@article{lazy_mark_scan,
	title = {Cyclic {Reference} {Counting} {With} {Lazy} {Mark}-{Scan}},
	volume = {44},
	issn = {0020-0190},
	url = {http://dx.doi.org/10.1016/0020-0190(92)90088-D},
	abstract = {this paper is much higher than the original one for cyclic reference counting with local mark-scan. More shared cells will now be claimed directly, without any need for mark-scan. The deletion of the last pointer to a shared cell will recycle it immediately, regardless of whether there is a reference to it on the queue. The queue will be left basically with pointers to cycles and pointers to green cells in the free-list or recycled. In this case again, our algorithm performs far better than the original one. In the best case, only one local mark-scan will be performed per cycle, instead of as many as the number of external references to a cycle, as before.},
	language = {en},
	number = {4},
	urldate = {2024-09-18},
	journal = {Information Processing Letters},
	author = {Lins, Rafael D.},
	month = dec,
	year = {1992},
	note = {Number: 4
Publisher: Elsevier Science Bv, Po Box 211, 1000 Ae Amsterdam, Netherlands},
	pages = {215--220},
	file = {Full Text PDF:C\:\\Users\\yasht\\Zotero\\storage\\DVE2LKA5\\Lins - 1992 - Cyclic Reference Counting With Lazy Mark-Scan.pdf:application/pdf;Snapshot:C\:\\Users\\yasht\\Zotero\\storage\\CDRGRICK\\22347.html:text/html},
}

@article{morris_chang_cyclic_2012,
	series = {{SMALLTALKS} 2010},
	title = {Cyclic reference counting by typed reference fields},
	volume = {38},
	issn = {1477-8424},
	url = {https://www.sciencedirect.com/science/article/pii/S1477842411000285},
	doi = {10.1016/j.cl.2011.09.001},
	abstract = {Reference counting strategy is a natural choice for real-time garbage collection, but the cycle collection phase which is required to ensure the correctness for reference counting algorithms can introduce heavy scanning overheads. This degrades the efficiency and inflates the pause time required for garbage collection. In this paper, we present two schemes to improve the efficiency of reference counting algorithms. First, in order to make better use of the semantics of a given program, we introduce a novel classification model to predict the behavior of objects precisely. Second, in order to reduce the scanning overheads, we propose an enhancement for cyclic reference counting algorithms by utilizing strongly-typed reference features of the Java language. We implement our proposed algorithm in Jikes RVM and measure the performance over various Java benchmarks. Our results show that the number of scanned objects can be reduced by an average of 37.9\% during cycle collection phase.},
	number = {1},
	urldate = {2024-09-13},
	journal = {Computer Languages, Systems \& Structures},
	author = {Morris Chang, J. and Chen, Wei-Mei and Griffin, Paul A. and Cheng, Ho-Yuan},
	month = apr,
	year = {2012},
	keywords = {reference counting, Garbage collection, Java, Memory management},
	pages = {98--107},
	file = {PDF:C\:\\Users\\yasht\\Zotero\\storage\\IFPWL334\\Morris Chang et al. - 2012 - Cyclic reference counting by typed reference fields.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\yasht\\Zotero\\storage\\FHPHZGUW\\S1477842411000285.html:text/html},
}

@inproceedings{compiler_optimizations_joisha,
	address={New York, NY, USA},
	series={ISMM ’06},
	title={Compiler optimizations for nondeferred reference: counting garbage collection},
	ISBN={978-1-59593-221-1},
	url={https://dl.acm.org/doi/10.1145/1133956.1133976},
	DOI={10.1145/1133956.1133976},
	abstractNote={Reference counting is a well-known technique for automatic memory management, offering unique advantages over other forms of garbage collection. However, on account of the high costs associated with the maintenance of up-to-date tallies of references from the stack, deferred variants are typically used in modern implementations. This partially sacrifices some of the benefits of non-deferred reference-counting (RC) garbage collection, like the immediate reclamation of garbage and short collector pause times.This paper presents a series of optimizations that target the stack and substantially enhance the throughput of nondeferred RC collection. A key enabler is a new static analysis and optimization called RC subsumption that significantly reduces the overhead of maintaining the stack contribution to reference counts. We report execution time improvements on a benchmark suite of ten C# programs, and show how RC subsumption, aided with other optimizations, improves the performance of nondeferred RC collection by as much as a factor of 10, making possible running times that are within 32% of that with an advanced traversal-based collector on seven programs, and 19% of that with a deferred RC collector on eight programs. This is in the context of a baseline RC implementation that is typically at least a factor of 6 slower than the tracing collector and a factor of 5 slower than the deferred RC collector.},
	booktitle={Proceedings of the 5th international symposium on Memory management},
	publisher={Association for Computing Machinery},
	author={Joisha, Pramod G.},
	year={2006},
	month=jun,
	pages={150–161},
	collection={ISMM ’06}
}

 @inproceedings{java_without_coffee_breaks, address={New York, NY, USA}, series={PLDI ’01}, title={Java without the coffee breaks: a nonintrusive multiprocessor garbage collector}, ISBN={978-1-58113-414-8}, url={https://dl.acm.org/doi/10.1145/378795.378819}, DOI={10.1145/378795.378819}, abstractNote={The deployment of Java as a concurrent programming language has created a critical need for high-performance, concurrent, and incremental multiprocessor garbage collection. We present the Recycler, a fully concurrent pure reference counting garbage collector that we have implemented in the Jalapeño Java virtual machine running on shared memory multiprocessors.While a variety of multiprocessor collectors have been proposed and some have been implemented, experimental data is limited and there is little quantitative basis for comparison between different algorithms. We present measurements of the Recycler and compare it against a non-concurrent but parallel load-balancing mark-and-sweep collector (that we also implemented in Jalapeño), and evaluate the classical tradeoff between response time and throughput.When processor or memory resources are limited, the Recycler runs at about 90% of the speed of the mark-and-sweep collector. However, with an extra processor to run collection and with a moderate amount of memory headroom, the Recycler is able to operate without ever blocking the mutators and achieves a maximum measured mutator delay of only 2.6 milliseconds for our benchmarks. End-to-end execution time is usually within 5%.}, booktitle={Proceedings of the ACM SIGPLAN 2001 conference on Programming language design and implementation}, publisher={Association for Computing Machinery}, author={Bacon, David F. and Attanasio, Clement R. and Lee, Han B. and Rajan, V. T. and Smith, Stephen}, year={2001}, month=may, pages={92–103}, collection={PLDI ’01} }
 @inproceedings{Bacon_Rajan_concurrent_collection, address={Berlin, Heidelberg}, title={Concurrent Cycle Collection in Reference Counted Systems}, ISBN={978-3-540-45337-6}, DOI={10.1007/3-540-45337-7_12}, abstractNote={Automatic storage reclamation via reference counting has important advantages, but has always suffered from a major weakness due to its inability to reclaim cyclic data structures.}, booktitle={ECOOP 2001 — Object-Oriented Programming}, publisher={Springer}, author={Bacon, David F. and Rajan, V. T.}, editor={Knudsen, Jørgen Lindskov}, year={2001}, pages={207–235}, language={en} }

